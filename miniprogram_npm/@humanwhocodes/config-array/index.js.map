{"version":3,"sources":["api.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar path = require('path');\nvar minimatch = require('minimatch');\nvar createDebug = require('debug');\nvar objectSchema = require('@humanwhocodes/object-schema');\n\n/**\n * @fileoverview ConfigSchema\n * @author Nicholas C. Zakas\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst NOOP_STRATEGY = {\n\trequired: false,\n\tmerge() {\n\t\treturn undefined;\n\t},\n\tvalidate() { }\n};\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The base schema that every ConfigArray uses.\n * @type Object\n */\nconst baseSchema = Object.freeze({\n\tname: {\n\t\trequired: false,\n\t\tmerge() {\n\t\t\treturn undefined;\n\t\t},\n\t\tvalidate(value) {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError('Property must be a string.');\n\t\t\t}\n\t\t}\n\t},\n\tfiles: NOOP_STRATEGY,\n\tignores: NOOP_STRATEGY\n});\n\n/**\n * @fileoverview ConfigSchema\n * @author Nicholas C. Zakas\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Asserts that a given value is an array.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array.\n */\nfunction assertIsArray(value) {\n\tif (!Array.isArray(value)) {\n\t\tthrow new TypeError('Expected value to be an array.');\n\t}\n}\n\n/**\n * Asserts that a given value is an array containing only strings and functions.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array of strings and functions.\n */\nfunction assertIsArrayOfStringsAndFunctions(value, name) {\n\tassertIsArray(value);\n\n\tif (value.some(item => typeof item !== 'string' && typeof item !== 'function')) {\n\t\tthrow new TypeError('Expected array to only contain strings and functions.');\n\t}\n}\n\n/**\n * Asserts that a given value is a non-empty array.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array or an empty array.\n */\nfunction assertIsNonEmptyArray(value) {\n\tif (!Array.isArray(value) || value.length === 0) {\n\t\tthrow new TypeError('Expected value to be a non-empty array.');\n\t}\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The schema for `files` and `ignores` that every ConfigArray uses.\n * @type Object\n */\nconst filesAndIgnoresSchema = Object.freeze({\n\tfiles: {\n\t\trequired: false,\n\t\tmerge() {\n\t\t\treturn undefined;\n\t\t},\n\t\tvalidate(value) {\n\n\t\t\t// first check if it's an array\n\t\t\tassertIsNonEmptyArray(value);\n\n\t\t\t// then check each member\n\t\t\tvalue.forEach(item => {\n\t\t\t\tif (Array.isArray(item)) {\n\t\t\t\t\tassertIsArrayOfStringsAndFunctions(item);\n\t\t\t\t} else if (typeof item !== 'string' && typeof item !== 'function') {\n\t\t\t\t\tthrow new TypeError('Items must be a string, a function, or an array of strings and functions.');\n\t\t\t\t}\n\t\t\t});\n\n\t\t}\n\t},\n\tignores: {\n\t\trequired: false,\n\t\tmerge() {\n\t\t\treturn undefined;\n\t\t},\n\t\tvalidate: assertIsArrayOfStringsAndFunctions\n\t}\n});\n\n/**\n * @fileoverview ConfigArray\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst Minimatch = minimatch.Minimatch;\nconst minimatchCache = new Map();\nconst negatedMinimatchCache = new Map();\nconst debug = createDebug('@hwc/config-array');\n\nconst MINIMATCH_OPTIONS = {\n\t// matchBase: true,\n\tdot: true\n};\n\nconst CONFIG_TYPES = new Set(['array', 'function']);\n\nconst FILES_AND_IGNORES_SCHEMA = new objectSchema.ObjectSchema(filesAndIgnoresSchema);\n\n/**\n * Shorthand for checking if a value is a string.\n * @param {any} value The value to check.\n * @returns {boolean} True if a string, false if not. \n */\nfunction isString(value) {\n\treturn typeof value === 'string';\n}\n\n/**\n * Asserts that the files and ignores keys of a config object are valid as per base schema.\n * @param {object} config The config object to check.\n * @returns {void}\n * @throws {TypeError} If the files and ignores keys of a config object are not valid.\n */\nfunction assertValidFilesAndIgnores(config) {\n\tif (!config || typeof config !== 'object') {\n\t\treturn;\n\t}\n\tconst validateConfig = { };\n\tif ('files' in config) {\n\t\tvalidateConfig.files = config.files;\n\t}\n\tif ('ignores' in config) {\n\t\tvalidateConfig.ignores = config.ignores;\n\t}\n\tFILES_AND_IGNORES_SCHEMA.validate(validateConfig);\n}\n\n/**\n * Wrapper around minimatch that caches minimatch patterns for\n * faster matching speed over multiple file path evaluations.\n * @param {string} filepath The file path to match.\n * @param {string} pattern The glob pattern to match against.\n * @param {object} options The minimatch options to use.\n * @returns \n */\nfunction doMatch(filepath, pattern, options = {}) {\n\n\tlet cache = minimatchCache;\n\n\tif (options.flipNegate) {\n\t\tcache = negatedMinimatchCache;\n\t}\n\n\tlet matcher = cache.get(pattern);\n\n\tif (!matcher) {\n\t\tmatcher = new Minimatch(pattern, Object.assign({}, MINIMATCH_OPTIONS, options));\n\t\tcache.set(pattern, matcher);\n\t}\n\n\treturn matcher.match(filepath);\n}\n\n/**\n * Normalizes a `ConfigArray` by flattening it and executing any functions\n * that are found inside.\n * @param {Array} items The items in a `ConfigArray`.\n * @param {Object} context The context object to pass into any function\n *      found.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {Promise<Array>} A flattened array containing only config objects.\n * @throws {TypeError} When a config function returns a function.\n */\nasync function normalize(items, context, extraConfigTypes) {\n\n\tconst allowFunctions = extraConfigTypes.includes('function');\n\tconst allowArrays = extraConfigTypes.includes('array');\n\n\tasync function* flatTraverse(array) {\n\t\tfor (let item of array) {\n\t\t\tif (typeof item === 'function') {\n\t\t\t\tif (!allowFunctions) {\n\t\t\t\t\tthrow new TypeError('Unexpected function.');\n\t\t\t\t}\n\n\t\t\t\titem = item(context);\n\t\t\t\tif (item.then) {\n\t\t\t\t\titem = await item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\tif (!allowArrays) {\n\t\t\t\t\tthrow new TypeError('Unexpected array.');\n\t\t\t\t}\n\t\t\t\tyield* flatTraverse(item);\n\t\t\t} else if (typeof item === 'function') {\n\t\t\t\tthrow new TypeError('A config function can only return an object or array.');\n\t\t\t} else {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Async iterables cannot be used with the spread operator, so we need to manually\n\t * create the array to return.\n\t */\n\tconst asyncIterable = await flatTraverse(items);\n\tconst configs = [];\n\n\tfor await (const config of asyncIterable) {\n\t\tconfigs.push(config);\n\t}\n\n\treturn configs;\n}\n\n/**\n * Normalizes a `ConfigArray` by flattening it and executing any functions\n * that are found inside.\n * @param {Array} items The items in a `ConfigArray`.\n * @param {Object} context The context object to pass into any function\n *      found.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {Array} A flattened array containing only config objects.\n * @throws {TypeError} When a config function returns a function.\n */\nfunction normalizeSync(items, context, extraConfigTypes) {\n\n\tconst allowFunctions = extraConfigTypes.includes('function');\n\tconst allowArrays = extraConfigTypes.includes('array');\n\n\tfunction* flatTraverse(array) {\n\t\tfor (let item of array) {\n\t\t\tif (typeof item === 'function') {\n\n\t\t\t\tif (!allowFunctions) {\n\t\t\t\t\tthrow new TypeError('Unexpected function.');\n\t\t\t\t}\n\n\t\t\t\titem = item(context);\n\t\t\t\tif (item.then) {\n\t\t\t\t\tthrow new TypeError('Async config functions are not supported.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Array.isArray(item)) {\n\n\t\t\t\tif (!allowArrays) {\n\t\t\t\t\tthrow new TypeError('Unexpected array.');\n\t\t\t\t}\n\n\t\t\t\tyield* flatTraverse(item);\n\t\t\t} else if (typeof item === 'function') {\n\t\t\t\tthrow new TypeError('A config function can only return an object or array.');\n\t\t\t} else {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [...flatTraverse(items)];\n}\n\n/**\n * Determines if a given file path should be ignored based on the given\n * matcher.\n * @param {Array<string|() => boolean>} ignores The ignore patterns to check. \n * @param {string} filePath The absolute path of the file to check.\n * @param {string} relativeFilePath The relative path of the file to check.\n * @returns {boolean} True if the path should be ignored and false if not.\n */\nfunction shouldIgnorePath(ignores, filePath, relativeFilePath) {\n\n\t// all files outside of the basePath are ignored\n\tif (relativeFilePath.startsWith('..')) {\n\t\treturn true;\n\t}\n\n\treturn ignores.reduce((ignored, matcher) => {\n\n\t\tif (!ignored) {\n\n\t\t\tif (typeof matcher === 'function') {\n\t\t\t\treturn matcher(filePath);\n\t\t\t}\n\n\t\t\t// don't check negated patterns because we're not ignored yet\n\t\t\tif (!matcher.startsWith('!')) {\n\t\t\t\treturn doMatch(relativeFilePath, matcher);\n\t\t\t}\n\n\t\t\t// otherwise we're still not ignored\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// only need to check negated patterns because we're ignored\n\t\tif (typeof matcher === 'string' && matcher.startsWith('!')) {\n\t\t\treturn !doMatch(relativeFilePath, matcher, {\n\t\t\t\tflipNegate: true\n\t\t\t});\n\t\t}\n\n\t\treturn ignored;\n\n\t}, false);\n\n}\n\n/**\n * Determines if a given file path is matched by a config based on\n * `ignores` only.\n * @param {string} filePath The absolute file path to check.\n * @param {string} basePath The base path for the config.\n * @param {Object} config The config object to check.\n * @returns {boolean} True if the file path is matched by the config,\n *      false if not.\n */\nfunction pathMatchesIgnores(filePath, basePath, config) {\n\n\t/*\n\t * For both files and ignores, functions are passed the absolute\n\t * file path while strings are compared against the relative\n\t * file path.\n\t */\n\tconst relativeFilePath = path.relative(basePath, filePath);\n\n\treturn Object.keys(config).length > 1 &&\n\t\t!shouldIgnorePath(config.ignores, filePath, relativeFilePath);\n}\n\n\n/**\n * Determines if a given file path is matched by a config. If the config\n * has no `files` field, then it matches; otherwise, if a `files` field\n * is present then we match the globs in `files` and exclude any globs in\n * `ignores`.\n * @param {string} filePath The absolute file path to check.\n * @param {string} basePath The base path for the config.\n * @param {Object} config The config object to check.\n * @returns {boolean} True if the file path is matched by the config,\n *      false if not.\n */\nfunction pathMatches(filePath, basePath, config) {\n\n\t/*\n\t * For both files and ignores, functions are passed the absolute\n\t * file path while strings are compared against the relative\n\t * file path.\n\t */\n\tconst relativeFilePath = path.relative(basePath, filePath);\n\n\t// match both strings and functions\n\tconst match = pattern => {\n\n\t\tif (isString(pattern)) {\n\t\t\treturn doMatch(relativeFilePath, pattern);\n\t\t}\n\n\t\tif (typeof pattern === 'function') {\n\t\t\treturn pattern(filePath);\n\t\t}\n\n\t\tthrow new TypeError(`Unexpected matcher type ${pattern}.`);\n\t};\n\n\t// check for all matches to config.files\n\tlet filePathMatchesPattern = config.files.some(pattern => {\n\t\tif (Array.isArray(pattern)) {\n\t\t\treturn pattern.every(match);\n\t\t}\n\n\t\treturn match(pattern);\n\t});\n\n\t/*\n\t * If the file path matches the config.files patterns, then check to see\n\t * if there are any files to ignore.\n\t */\n\tif (filePathMatchesPattern && config.ignores) {\n\t\tfilePathMatchesPattern = !shouldIgnorePath(config.ignores, filePath, relativeFilePath);\n\t}\n\n\treturn filePathMatchesPattern;\n}\n\n/**\n * Ensures that a ConfigArray has been normalized.\n * @param {ConfigArray} configArray The ConfigArray to check. \n * @returns {void}\n * @throws {Error} When the `ConfigArray` is not normalized.\n */\nfunction assertNormalized(configArray) {\n\t// TODO: Throw more verbose error\n\tif (!configArray.isNormalized()) {\n\t\tthrow new Error('ConfigArray must be normalized to perform this operation.');\n\t}\n}\n\n/**\n * Ensures that config types are valid.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {void}\n * @throws {Error} When the config types array is invalid.\n */\nfunction assertExtraConfigTypes(extraConfigTypes) {\n\tif (extraConfigTypes.length > 2) {\n\t\tthrow new TypeError('configTypes must be an array with at most two items.');\n\t}\n\n\tfor (const configType of extraConfigTypes) {\n\t\tif (!CONFIG_TYPES.has(configType)) {\n\t\t\tthrow new TypeError(`Unexpected config type \"${configType}\" found. Expected one of: \"object\", \"array\", \"function\".`);\n\t\t}\n\t}\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nconst ConfigArraySymbol = {\n\tisNormalized: Symbol('isNormalized'),\n\tconfigCache: Symbol('configCache'),\n\tschema: Symbol('schema'),\n\tfinalizeConfig: Symbol('finalizeConfig'),\n\tpreprocessConfig: Symbol('preprocessConfig')\n};\n\n// used to store calculate data for faster lookup\nconst dataCache = new WeakMap();\n\n/**\n * Represents an array of config objects and provides method for working with\n * those config objects.\n */\nclass ConfigArray extends Array {\n\n\t/**\n\t * Creates a new instance of ConfigArray.\n\t * @param {Iterable|Function|Object} configs An iterable yielding config\n\t *      objects, or a config function, or a config object.\n\t * @param {string} [options.basePath=\"\"] The path of the config file\n\t * @param {boolean} [options.normalized=false] Flag indicating if the\n\t *      configs have already been normalized.\n\t * @param {Object} [options.schema] The additional schema \n\t *      definitions to use for the ConfigArray schema.\n\t * @param {Array<string>} [options.configTypes] List of config types supported.\n\t */\n\tconstructor(configs, {\n\t\tbasePath = '',\n\t\tnormalized = false,\n\t\tschema: customSchema,\n\t\textraConfigTypes = []\n\t} = {}\n\t) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Tracks if the array has been normalized.\n\t\t * @property isNormalized\n\t\t * @type boolean\n\t\t * @private\n\t\t */\n\t\tthis[ConfigArraySymbol.isNormalized] = normalized;\n\n\t\t/**\n\t\t * The schema used for validating and merging configs.\n\t\t * @property schema\n\t\t * @type ObjectSchema\n\t\t * @private\n\t\t */\n\t\tthis[ConfigArraySymbol.schema] = new objectSchema.ObjectSchema(\n\t\t\tObject.assign({}, customSchema, baseSchema)\n\t\t);\n\n\t\t/**\n\t\t * The path of the config file that this array was loaded from.\n\t\t * This is used to calculate filename matches.\n\t\t * @property basePath\n\t\t * @type string\n\t\t */\n\t\tthis.basePath = basePath;\n\n\t\tassertExtraConfigTypes(extraConfigTypes);\n\n\t\t/**\n\t\t * The supported config types.\n\t\t * @property configTypes\n\t\t * @type Array<string>\n\t\t */\n\t\tthis.extraConfigTypes = Object.freeze([...extraConfigTypes]);\n\n\t\t/**\n\t\t * A cache to store calculated configs for faster repeat lookup.\n\t\t * @property configCache\n\t\t * @type Map\n\t\t * @private\n\t\t */\n\t\tthis[ConfigArraySymbol.configCache] = new Map();\n\n\t\t// init cache\n\t\tdataCache.set(this, {\n\t\t\texplicitMatches: new Map(),\n\t\t\tdirectoryMatches: new Map(),\n\t\t\tfiles: undefined,\n\t\t\tignores: undefined\n\t\t});\n\n\t\t// load the configs into this array\n\t\tif (Array.isArray(configs)) {\n\t\t\tthis.push(...configs);\n\t\t} else {\n\t\t\tthis.push(configs);\n\t\t}\n\n\t}\n\n\t/**\n\t * Prevent normal array methods from creating a new `ConfigArray` instance.\n\t * This is to ensure that methods such as `slice()` won't try to create a \n\t * new instance of `ConfigArray` behind the scenes as doing so may throw\n\t * an error due to the different constructor signature.\n\t * @returns {Function} The `Array` constructor.\n\t */\n\tstatic get [Symbol.species]() {\n\t\treturn Array;\n\t}\n\n\t/**\n\t * Returns the `files` globs from every config object in the array.\n\t * This can be used to determine which files will be matched by a\n\t * config array or to use as a glob pattern when no patterns are provided\n\t * for a command line interface.\n\t * @returns {Array<string|Function>} An array of matchers.\n\t */\n\tget files() {\n\n\t\tassertNormalized(this);\n\n\t\t// if this data has been cached, retrieve it\n\t\tconst cache = dataCache.get(this);\n\n\t\tif (cache.files) {\n\t\t\treturn cache.files;\n\t\t}\n\n\t\t// otherwise calculate it\n\n\t\tconst result = [];\n\n\t\tfor (const config of this) {\n\t\t\tif (config.files) {\n\t\t\t\tconfig.files.forEach(filePattern => {\n\t\t\t\t\tresult.push(filePattern);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// store result\n\t\tcache.files = result;\n\t\tdataCache.set(this, cache);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns ignore matchers that should always be ignored regardless of\n\t * the matching `files` fields in any configs. This is necessary to mimic\n\t * the behavior of things like .gitignore and .eslintignore, allowing a\n\t * globbing operation to be faster.\n\t * @returns {string[]} An array of string patterns and functions to be ignored.\n\t */\n\tget ignores() {\n\n\t\tassertNormalized(this);\n\n\t\t// if this data has been cached, retrieve it\n\t\tconst cache = dataCache.get(this);\n\n\t\tif (cache.ignores) {\n\t\t\treturn cache.ignores;\n\t\t}\n\n\t\t// otherwise calculate it\n\n\t\tconst result = [];\n\n\t\tfor (const config of this) {\n\n\t\t\t/*\n\t\t\t * We only count ignores if there are no other keys in the object.\n\t\t\t * In this case, it acts list a globally ignored pattern. If there\n\t\t\t * are additional keys, then ignores act like exclusions.\n\t\t\t */\n\t\t\tif (config.ignores && Object.keys(config).length === 1) {\n\t\t\t\tresult.push(...config.ignores);\n\t\t\t}\n\t\t}\n\n\t\t// store result\n\t\tcache.ignores = result;\n\t\tdataCache.set(this, cache);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Indicates if the config array has been normalized.\n\t * @returns {boolean} True if the config array is normalized, false if not.\n\t */\n\tisNormalized() {\n\t\treturn this[ConfigArraySymbol.isNormalized];\n\t}\n\n\t/**\n\t * Normalizes a config array by flattening embedded arrays and executing\n\t * config functions.\n\t * @param {ConfigContext} context The context object for config functions.\n\t * @returns {Promise<ConfigArray>} The current ConfigArray instance.\n\t */\n\tasync normalize(context = {}) {\n\n\t\tif (!this.isNormalized()) {\n\t\t\tconst normalizedConfigs = await normalize(this, context, this.extraConfigTypes);\n\t\t\tthis.length = 0;\n\t\t\tthis.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig].bind(this)));\n\t\t\tthis.forEach(assertValidFilesAndIgnores);\n\t\t\tthis[ConfigArraySymbol.isNormalized] = true;\n\n\t\t\t// prevent further changes\n\t\t\tObject.freeze(this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Normalizes a config array by flattening embedded arrays and executing\n\t * config functions.\n\t * @param {ConfigContext} context The context object for config functions.\n\t * @returns {ConfigArray} The current ConfigArray instance.\n\t */\n\tnormalizeSync(context = {}) {\n\n\t\tif (!this.isNormalized()) {\n\t\t\tconst normalizedConfigs = normalizeSync(this, context, this.extraConfigTypes);\n\t\t\tthis.length = 0;\n\t\t\tthis.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig].bind(this)));\n\t\t\tthis.forEach(assertValidFilesAndIgnores);\n\t\t\tthis[ConfigArraySymbol.isNormalized] = true;\n\n\t\t\t// prevent further changes\n\t\t\tObject.freeze(this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Finalizes the state of a config before being cached and returned by\n\t * `getConfig()`. Does nothing by default but is provided to be\n\t * overridden by subclasses as necessary.\n\t * @param {Object} config The config to finalize.\n\t * @returns {Object} The finalized config.\n\t */\n\t[ConfigArraySymbol.finalizeConfig](config) {\n\t\treturn config;\n\t}\n\n\t/**\n\t * Preprocesses a config during the normalization process. This is the\n\t * method to override if you want to convert an array item before it is\n\t * validated for the first time. For example, if you want to replace a\n\t * string with an object, this is the method to override.\n\t * @param {Object} config The config to preprocess.\n\t * @returns {Object} The config to use in place of the argument.\n\t */\n\t[ConfigArraySymbol.preprocessConfig](config) {\n\t\treturn config;\n\t}\n\n\t/**\n\t * Determines if a given file path explicitly matches a `files` entry\n\t * and also doesn't match an `ignores` entry. Configs that don't have\n\t * a `files` property are not considered an explicit match.\n\t * @param {string} filePath The complete path of a file to check.\n\t * @returns {boolean} True if the file path matches a `files` entry\n\t * \t\tor false if not.\n\t */\n\tisExplicitMatch(filePath) {\n\n\t\tassertNormalized(this);\n\n\t\tconst cache = dataCache.get(this);\n\n\t\t// first check the cache to avoid duplicate work\n\t\tlet result = cache.explicitMatches.get(filePath);\n\n\t\tif (typeof result == 'boolean') {\n\t\t\treturn result;\n\t\t}\n\n\t\t// TODO: Maybe move elsewhere? Maybe combine with getConfig() logic?\n\t\tconst relativeFilePath = path.relative(this.basePath, filePath);\n\n\t\tif (shouldIgnorePath(this.ignores, filePath, relativeFilePath)) {\n\t\t\tdebug(`Ignoring ${filePath}`);\n\n\t\t\t// cache and return result\n\t\t\tcache.explicitMatches.set(filePath, false);\n\t\t\treturn false;\n\t\t}\n\n\t\t// filePath isn't automatically ignored, so try to find a match\n\n\t\tfor (const config of this) {\n\n\t\t\tif (!config.files) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (pathMatches(filePath, this.basePath, config)) {\n\t\t\t\tdebug(`Matching config found for ${filePath}`);\n\t\t\t\tcache.explicitMatches.set(filePath, true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns the config object for a given file path.\n\t * @param {string} filePath The complete path of a file to get a config for.\n\t * @returns {Object} The config object for this file.\n\t */\n\tgetConfig(filePath) {\n\n\t\tassertNormalized(this);\n\n\t\tconst cache = this[ConfigArraySymbol.configCache];\n\n\t\t// first check the cache for a filename match to avoid duplicate work\n\t\tif (cache.has(filePath)) {\n\t\t\treturn cache.get(filePath);\n\t\t}\n\n\t\tlet finalConfig;\n\n\t\t// next check to see if the file should be ignored\n\n\t\t// check if this should be ignored due to its directory\n\t\tif (this.isDirectoryIgnored(path.dirname(filePath))) {\n\t\t\tdebug(`Ignoring ${filePath} based on directory pattern`);\n\n\t\t\t// cache and return result - finalConfig is undefined at this point\n\t\t\tcache.set(filePath, finalConfig);\n\t\t\treturn finalConfig;\n\t\t}\n\n\t\t// TODO: Maybe move elsewhere?\n\t\tconst relativeFilePath = path.relative(this.basePath, filePath);\n\n\t\tif (shouldIgnorePath(this.ignores, filePath, relativeFilePath)) {\n\t\t\tdebug(`Ignoring ${filePath} based on file pattern`);\n\n\t\t\t// cache and return result - finalConfig is undefined at this point\n\t\t\tcache.set(filePath, finalConfig);\n\t\t\treturn finalConfig;\n\t\t}\n\n\t\t// filePath isn't automatically ignored, so try to construct config\n\n\t\tconst matchingConfigIndices = [];\n\t\tlet matchFound = false;\n\t\tconst universalPattern = /\\/\\*{1,2}$/;\n\n\t\tthis.forEach((config, index) => {\n\n\t\t\tif (!config.files) {\n\n\t\t\t\tif (!config.ignores) {\n\t\t\t\t\tdebug(`Anonymous universal config found for ${filePath}`);\n\t\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (pathMatchesIgnores(filePath, this.basePath, config)) {\n\t\t\t\t\tdebug(`Matching config found for ${filePath} (based on ignores: ${config.ignores})`);\n\t\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdebug(`Skipped config found for ${filePath} (based on ignores: ${config.ignores})`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If a config has a files pattern ending in /** or /*, and the\n\t\t\t * filePath only matches those patterns, then the config is only\n\t\t\t * applied if there is another config where the filePath matches\n\t\t\t * a file with a specific extensions such as *.js.\n\t\t\t */\n\n\t\t\tconst universalFiles = config.files.filter(\n\t\t\t\tpattern => universalPattern.test(pattern)\n\t\t\t);\n\n\t\t\t// universal patterns were found so we need to check the config twice\n\t\t\tif (universalFiles.length) {\n\n\t\t\t\tdebug('Universal files patterns found. Checking carefully.');\n\n\t\t\t\tconst nonUniversalFiles = config.files.filter(\n\t\t\t\t\tpattern => !universalPattern.test(pattern)\n\t\t\t\t);\n\n\t\t\t\t// check that the config matches without the non-universal files first\n\t\t\t\tif (\n\t\t\t\t\tnonUniversalFiles.length && \n\t\t\t\t\tpathMatches(\n\t\t\t\t\t\tfilePath, this.basePath,\n\t\t\t\t\t\t{ files: nonUniversalFiles, ignores: config.ignores }\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tdebug(`Matching config found for ${filePath}`);\n\t\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\t\tmatchFound = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// if there wasn't a match then check if it matches with universal files\n\t\t\t\tif (\n\t\t\t\t\tuniversalFiles.length &&\n\t\t\t\t\tpathMatches(\n\t\t\t\t\t\tfilePath, this.basePath,\n\t\t\t\t\t\t{ files: universalFiles, ignores: config.ignores }\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tdebug(`Matching config found for ${filePath}`);\n\t\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// if we make here, then there was no match\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// the normal case\n\t\t\tif (pathMatches(filePath, this.basePath, config)) {\n\t\t\t\tdebug(`Matching config found for ${filePath}`);\n\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\tmatchFound = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t});\n\n\t\t// if matching both files and ignores, there will be no config to create\n\t\tif (!matchFound) {\n\t\t\tdebug(`No matching configs found for ${filePath}`);\n\n\t\t\t// cache and return result - finalConfig is undefined at this point\n\t\t\tcache.set(filePath, finalConfig);\n\t\t\treturn finalConfig;\n\t\t}\n\n\t\t// check to see if there is a config cached by indices\n\t\tfinalConfig = cache.get(matchingConfigIndices.toString());\n\n\t\tif (finalConfig) {\n\n\t\t\t// also store for filename for faster lookup next time\n\t\t\tcache.set(filePath, finalConfig);\n\n\t\t\treturn finalConfig;\n\t\t}\n\n\t\t// otherwise construct the config\n\n\t\tfinalConfig = matchingConfigIndices.reduce((result, index) => {\n\t\t\treturn this[ConfigArraySymbol.schema].merge(result, this[index]);\n\t\t}, {}, this);\n\n\t\tfinalConfig = this[ConfigArraySymbol.finalizeConfig](finalConfig);\n\n\t\tcache.set(filePath, finalConfig);\n\t\tcache.set(matchingConfigIndices.toString(), finalConfig);\n\n\t\treturn finalConfig;\n\t}\n\n\t/**\n\t * Determines if the given filepath is ignored based on the configs.\n\t * @param {string} filePath The complete path of a file to check.\n\t * @returns {boolean} True if the path is ignored, false if not.\n\t * @deprecated Use `isFileIgnored` instead.\n\t */\n\tisIgnored(filePath) {\n\t\treturn this.isFileIgnored(filePath);\n\t}\n\n\t/**\n\t * Determines if the given filepath is ignored based on the configs.\n\t * @param {string} filePath The complete path of a file to check.\n\t * @returns {boolean} True if the path is ignored, false if not.\n\t */\n\tisFileIgnored(filePath) {\n\t\treturn this.getConfig(filePath) === undefined;\n\t}\n\n\t/**\n\t * Determines if the given directory is ignored based on the configs.\n\t * This checks only default `ignores` that don't have `files` in the \n\t * same config. A pattern such as `/foo` be considered to ignore the directory\n\t * while a pattern such as `/foo/**` is not considered to ignore the\n\t * directory because it is matching files.\n\t * @param {string} directoryPath The complete path of a directory to check.\n\t * @returns {boolean} True if the directory is ignored, false if not. Will\n\t * \t\treturn true for any directory that is not inside of `basePath`.\n\t * @throws {Error} When the `ConfigArray` is not normalized.\n\t */\n\tisDirectoryIgnored(directoryPath) {\n\n\t\tassertNormalized(this);\n\n\t\tconst relativeDirectoryPath = path.relative(this.basePath, directoryPath)\n\t\t\t.replace(/\\\\/g, '/');\n\n\t\tif (relativeDirectoryPath.startsWith('..')) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// first check the cache\n\t\tconst cache = dataCache.get(this).directoryMatches;\n\n\t\tif (cache.has(relativeDirectoryPath)) {\n\t\t\treturn cache.get(relativeDirectoryPath);\n\t\t}\n\n\t\tconst directoryParts = relativeDirectoryPath.split('/');\n\t\tlet relativeDirectoryToCheck = '';\n\t\tlet result = false;\n\n\t\t/*\n\t\t * In order to get the correct gitignore-style ignores, where an\n\t\t * ignored parent directory cannot have any descendants unignored,\n\t\t * we need to check every directory starting at the parent all\n\t\t * the way down to the actual requested directory.\n\t\t * \n\t\t * We aggressively cache all of this info to make sure we don't\n\t\t * have to recalculate everything for every call.\n\t\t */\n\t\tdo {\n\n\t\t\trelativeDirectoryToCheck += directoryParts.shift() + '/';\n\n\t\t\tresult = shouldIgnorePath(\n\t\t\t\tthis.ignores,\n\t\t\t\tpath.join(this.basePath, relativeDirectoryToCheck),\n\t\t\t\trelativeDirectoryToCheck\n\t\t\t);\n\n\t\t\tcache.set(relativeDirectoryToCheck, result);\n\n\t\t} while (!result && directoryParts.length);\n\n\t\t// also cache the result for the requested path\n\t\tcache.set(relativeDirectoryPath, result);\n\n\t\treturn result;\n\t}\n\n}\n\nexports.ConfigArray = ConfigArray;\nexports.ConfigArraySymbol = ConfigArraySymbol;\n"]}