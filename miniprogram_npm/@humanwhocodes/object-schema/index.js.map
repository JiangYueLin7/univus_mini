{"version":3,"sources":["index.js","object-schema.js","merge-strategy.js","validation-strategy.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/**\n * @filedescription Object Schema Package\n */\n\nexports.ObjectSchema = require(\"./object-schema\").ObjectSchema;\nexports.MergeStrategy = require(\"./merge-strategy\").MergeStrategy;\nexports.ValidationStrategy = require(\"./validation-strategy\").ValidationStrategy;\n","/**\n * @filedescription Object Schema\n */\n\n\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst { MergeStrategy } = require(\"./merge-strategy\");\nconst { ValidationStrategy } = require(\"./validation-strategy\");\n\n//-----------------------------------------------------------------------------\n// Private\n//-----------------------------------------------------------------------------\n\nconst strategies = Symbol(\"strategies\");\nconst requiredKeys = Symbol(\"requiredKeys\");\n\n/**\n * Validates a schema strategy.\n * @param {string} name The name of the key this strategy is for.\n * @param {Object} strategy The strategy for the object key.\n * @param {boolean} [strategy.required=true] Whether the key is required.\n * @param {string[]} [strategy.requires] Other keys that are required when\n *      this key is present.\n * @param {Function} strategy.merge A method to call when merging two objects\n *      with the same key.\n * @param {Function} strategy.validate A method to call when validating an\n *      object with the key.\n * @returns {void}\n * @throws {Error} When the strategy is missing a name.\n * @throws {Error} When the strategy is missing a merge() method.\n * @throws {Error} When the strategy is missing a validate() method.\n */\nfunction validateDefinition(name, strategy) {\n\n    let hasSchema = false;\n    if (strategy.schema) {\n        if (typeof strategy.schema === \"object\") {\n            hasSchema = true;\n        } else {\n            throw new TypeError(\"Schema must be an object.\");\n        }\n    }\n\n    if (typeof strategy.merge === \"string\") {\n        if (!(strategy.merge in MergeStrategy)) {\n            throw new TypeError(`Definition for key \"${name}\" missing valid merge strategy.`);\n        }\n    } else if (!hasSchema && typeof strategy.merge !== \"function\") {\n        throw new TypeError(`Definition for key \"${name}\" must have a merge property.`);\n    }\n\n    if (typeof strategy.validate === \"string\") {\n        if (!(strategy.validate in ValidationStrategy)) {\n            throw new TypeError(`Definition for key \"${name}\" missing valid validation strategy.`);\n        }\n    } else if (!hasSchema && typeof strategy.validate !== \"function\") {\n        throw new TypeError(`Definition for key \"${name}\" must have a validate() method.`);\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Errors\n//-----------------------------------------------------------------------------\n\n/**\n * Error when an unexpected key is found.\n */\nclass UnexpectedKeyError extends Error {\n\n    /**\n     * Creates a new instance.\n     * @param {string} key The key that was unexpected. \n     */\n    constructor(key) {\n        super(`Unexpected key \"${key}\" found.`);\n    }\n}\n\n/**\n * Error when a required key is missing.\n */\nclass MissingKeyError extends Error {\n\n    /**\n     * Creates a new instance.\n     * @param {string} key The key that was missing. \n     */\n    constructor(key) {\n        super(`Missing required key \"${key}\".`);\n    }\n}\n\n/**\n * Error when a key requires other keys that are missing.\n */\nclass MissingDependentKeysError extends Error {\n\n    /**\n     * Creates a new instance.\n     * @param {string} key The key that was unexpected.\n     * @param {Array<string>} requiredKeys The keys that are required.\n     */\n    constructor(key, requiredKeys) {\n        super(`Key \"${key}\" requires keys \"${requiredKeys.join(\"\\\", \\\"\")}\".`);\n    }\n}\n\n/**\n * Wrapper error for errors occuring during a merge or validate operation.\n */\nclass WrapperError extends Error {\n\n    /**\n     * Creates a new instance.\n     * @param {string} key The object key causing the error. \n     * @param {Error} source The source error. \n     */\n    constructor(key, source) {\n        super(`Key \"${key}\": ${source.message}`, { cause: source });\n\n        // copy over custom properties that aren't represented\n        for (const key of Object.keys(source)) {\n            if (!(key in this)) {\n                this[key] = source[key];\n            }\n        }\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Main\n//-----------------------------------------------------------------------------\n\n/**\n * Represents an object validation/merging schema.\n */\nclass ObjectSchema {\n\n    /**\n     * Creates a new instance.\n     */\n    constructor(definitions) {\n\n        if (!definitions) {\n            throw new Error(\"Schema definitions missing.\");\n        }\n\n        /**\n         * Track all strategies in the schema by key.\n         * @type {Map}\n         * @property strategies\n         */\n        this[strategies] = new Map();\n\n        /**\n         * Separately track any keys that are required for faster validation.\n         * @type {Map}\n         * @property requiredKeys\n         */\n        this[requiredKeys] = new Map();\n\n        // add in all strategies\n        for (const key of Object.keys(definitions)) {\n            validateDefinition(key, definitions[key]);\n\n            // normalize merge and validate methods if subschema is present\n            if (typeof definitions[key].schema === \"object\") {\n                const schema = new ObjectSchema(definitions[key].schema);\n                definitions[key] = {\n                    ...definitions[key],\n                    merge(first = {}, second = {}) {\n                        return schema.merge(first, second);\n                    },\n                    validate(value) {\n                        ValidationStrategy.object(value);\n                        schema.validate(value);\n                    }\n                };\n            }\n\n            // normalize the merge method in case there's a string\n            if (typeof definitions[key].merge === \"string\") {\n                definitions[key] = {\n                    ...definitions[key],\n                    merge: MergeStrategy[definitions[key].merge]\n                };\n            };\n\n            // normalize the validate method in case there's a string\n            if (typeof definitions[key].validate === \"string\") {\n                definitions[key] = {\n                    ...definitions[key],\n                    validate: ValidationStrategy[definitions[key].validate]\n                };\n            };\n\n            this[strategies].set(key, definitions[key]);\n\n            if (definitions[key].required) {\n                this[requiredKeys].set(key, definitions[key]);\n            }\n        }\n    }\n\n    /**\n     * Determines if a strategy has been registered for the given object key.\n     * @param {string} key The object key to find a strategy for.\n     * @returns {boolean} True if the key has a strategy registered, false if not. \n     */\n    hasKey(key) {\n        return this[strategies].has(key);\n    }\n\n    /**\n     * Merges objects together to create a new object comprised of the keys\n     * of the all objects. Keys are merged based on the each key's merge\n     * strategy.\n     * @param {...Object} objects The objects to merge.\n     * @returns {Object} A new object with a mix of all objects' keys.\n     * @throws {Error} If any object is invalid.\n     */\n    merge(...objects) {\n\n        // double check arguments\n        if (objects.length < 2) {\n            throw new TypeError(\"merge() requires at least two arguments.\");\n        }\n\n        if (objects.some(object => (object == null || typeof object !== \"object\"))) {\n            throw new TypeError(\"All arguments must be objects.\");\n        }\n\n        return objects.reduce((result, object) => {\n            \n            this.validate(object);\n            \n            for (const [key, strategy] of this[strategies]) {\n                try {\n                    if (key in result || key in object) {\n                        const value = strategy.merge.call(this, result[key], object[key]);\n                        if (value !== undefined) {\n                            result[key] = value;\n                        }\n                    }\n                } catch (ex) {\n                    throw new WrapperError(key, ex);\n                }\n            }\n            return result;\n        }, {});\n    }\n\n    /**\n     * Validates an object's keys based on the validate strategy for each key.\n     * @param {Object} object The object to validate.\n     * @returns {void}\n     * @throws {Error} When the object is invalid. \n     */\n    validate(object) {\n\n        // check existing keys first\n        for (const key of Object.keys(object)) {\n\n            // check to see if the key is defined\n            if (!this.hasKey(key)) {\n                throw new UnexpectedKeyError(key);\n            }\n\n            // validate existing keys\n            const strategy = this[strategies].get(key);\n\n            // first check to see if any other keys are required\n            if (Array.isArray(strategy.requires)) {\n                if (!strategy.requires.every(otherKey => otherKey in object)) {\n                    throw new MissingDependentKeysError(key, strategy.requires);\n                }\n            }\n\n            // now apply remaining validation strategy\n            try {\n                strategy.validate.call(strategy, object[key]);\n            } catch (ex) {\n                throw new WrapperError(key, ex);\n            }\n        }\n\n        // ensure required keys aren't missing\n        for (const [key] of this[requiredKeys]) {\n            if (!(key in object)) {\n                throw new MissingKeyError(key);\n            }\n        }\n\n    }\n}\n\nexports.ObjectSchema = ObjectSchema;\n","/**\n * @filedescription Merge Strategy\n */\n\n\n\n//-----------------------------------------------------------------------------\n// Class\n//-----------------------------------------------------------------------------\n\n/**\n * Container class for several different merge strategies.\n */\nclass MergeStrategy {\n\n    /**\n     * Merges two keys by overwriting the first with the second.\n     * @param {*} value1 The value from the first object key. \n     * @param {*} value2 The value from the second object key.\n     * @returns {*} The second value.\n     */\n    static overwrite(value1, value2) {\n        return value2;\n    }\n\n    /**\n     * Merges two keys by replacing the first with the second only if the\n     * second is defined.\n     * @param {*} value1 The value from the first object key. \n     * @param {*} value2 The value from the second object key.\n     * @returns {*} The second value if it is defined.\n     */\n    static replace(value1, value2) {\n        if (typeof value2 !== \"undefined\") {\n            return value2;\n        }\n\n        return value1;\n    }\n\n    /**\n     * Merges two properties by assigning properties from the second to the first.\n     * @param {*} value1 The value from the first object key.\n     * @param {*} value2 The value from the second object key.\n     * @returns {*} A new object containing properties from both value1 and\n     *      value2.\n     */\n    static assign(value1, value2) {\n        return Object.assign({}, value1, value2);\n    }\n}\n\nexports.MergeStrategy = MergeStrategy;\n","/**\n * @filedescription Validation Strategy\n */\n\n\n\n//-----------------------------------------------------------------------------\n// Class\n//-----------------------------------------------------------------------------\n\n/**\n * Container class for several different validation strategies.\n */\nclass ValidationStrategy {\n\n    /**\n     * Validates that a value is an array.\n     * @param {*} value The value to validate.\n     * @returns {void}\n     * @throws {TypeError} If the value is invalid. \n     */\n    static array(value) {\n        if (!Array.isArray(value)) {\n            throw new TypeError(\"Expected an array.\");\n        }\n    }\n\n    /**\n     * Validates that a value is a boolean.\n     * @param {*} value The value to validate.\n     * @returns {void}\n     * @throws {TypeError} If the value is invalid. \n     */\n    static boolean(value) {\n        if (typeof value !== \"boolean\") {\n            throw new TypeError(\"Expected a Boolean.\");\n        }\n    }\n\n    /**\n     * Validates that a value is a number.\n     * @param {*} value The value to validate.\n     * @returns {void}\n     * @throws {TypeError} If the value is invalid. \n     */\n    static number(value) {\n        if (typeof value !== \"number\") {\n            throw new TypeError(\"Expected a number.\");\n        }\n    }\n\n    /**\n     * Validates that a value is a object.\n     * @param {*} value The value to validate.\n     * @returns {void}\n     * @throws {TypeError} If the value is invalid. \n     */\n    static object(value) {\n        if (!value || typeof value !== \"object\") {\n            throw new TypeError(\"Expected an object.\");\n        }\n    }\n\n    /**\n     * Validates that a value is a object or null.\n     * @param {*} value The value to validate.\n     * @returns {void}\n     * @throws {TypeError} If the value is invalid. \n     */\n    static \"object?\"(value) {\n        if (typeof value !== \"object\") {\n            throw new TypeError(\"Expected an object or null.\");\n        }\n    }\n\n    /**\n     * Validates that a value is a string.\n     * @param {*} value The value to validate.\n     * @returns {void}\n     * @throws {TypeError} If the value is invalid. \n     */\n    static string(value) {\n        if (typeof value !== \"string\") {\n            throw new TypeError(\"Expected a string.\");\n        }\n    }\n\n    /**\n     * Validates that a value is a non-empty string.\n     * @param {*} value The value to validate.\n     * @returns {void}\n     * @throws {TypeError} If the value is invalid. \n     */\n    static \"string!\"(value) {\n        if (typeof value !== \"string\" || value.length === 0) {\n            throw new TypeError(\"Expected a non-empty string.\");\n        }\n    }\n\n}\n\nexports.ValidationStrategy = ValidationStrategy;\n"]}